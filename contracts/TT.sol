// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts v4.3.2 (token/ERC721/presets/ERC721PresetMinterPauserAutoId.sol)
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";

/**
 * @dev {ERC721} token, including:
 *
 *  - ability for holders to burn (destroy) their tokens
 *  - a minter role that allows for token minting (creation)
 *  - a pauser role that allows to stop all token transfers
 *  - token ID and URI autogeneration
 *
 * This contract uses {AccessControl} to lock permissioned functions using the
 * different roles - head to its documentation for details.
 *
 * The account that deploys the contract will be granted the minter and pauser
 * roles, as well as the default admin role, which will let it grant both minter
 * and pauser roles to other accounts.
 */
contract Kasiar is
     ERC721Enumerable, Ownable
 {
    uint256 public price = 50000000000000000; // 0.05 
    uint256 public maxPurchase = 10;
    uint256 public MAX_Kasiar = 3000;
    string private _baseTokenURI;
    // 0 = paused, 1 = presale, 2 = live
    uint256 public saleState = 0; 
    mapping(address => uint256) public preSaleReserved;

    // Rarity
    // 0 <= _tokenIdTrackerSSS < 2  2
    uint256 public SSS = 2;
    uint256 private _tokenIdTrackerSSS;
    // 2 <= _tokenIdTrackerSS < 18   16
    uint256 public SS = 16;
    uint256 private _tokenIdTrackerSS = 2;
    // 18 <= _tokenIdTrackerSS < 82  64
    uint256 public S = 64;
    uint256 private _tokenIdTrackerS = SSS+SS;
    // 82 <= _tokenIdTrackerSS < 3000  2918
    uint256 public A = 2918;
    uint256 private _tokenIdTrackerA = SSS+SS+ S;



    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `ADMIN_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(
        string memory name,
        string memory symbol,
        string memory baseTokenURI
    ) ERC721(name, symbol) {
        _baseTokenURI = baseTokenURI;
        preSaleReserved[msg.sender] = maxPurchase;
    }

    // Edit reserved presale spots
    function setPreSaleWhitelist(address[] memory _a)   
        public
        virtual
        onlyOwner 
    {
        for (uint256 i; i < _a.length; i++) {
            preSaleReserved[_a[i]] = maxPurchase;
        }
    }
    function preSaleMint(address to, uint256 num) public payable {
        uint256 supply = totalSupply();
        uint256 reservedAmt = preSaleReserved[to];
        require(saleState > 0, "Presale isn't active");
        require(reservedAmt > 0, "No tokens reserved for address");
        require(num <= reservedAmt, "Can't mint more than reserved");
        require(supply + num <= MAX_Kasiar, "Exceeds maximum Kasiar supply");
        require(msg.value >= price * num, "Ether sent is not correct");
        preSaleReserved[to] = reservedAmt - num;
        for (uint256 i; i < num; i++) {
           _mindRandom(to);
        }
    }
    
    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mint(address to, uint256 num) public payable virtual {
      require(saleState > 1, "Sale not live");
      require(num > 0, "Cannot buy 0");
      require(to != address(0x0), "address err");
      require(
          num <= maxPurchase,
          "Exceeds max number of Kasiar in one transaction"
      );
      uint256 supply = totalSupply();
      require(
          supply + num <= MAX_Kasiar,
          "Purchase would exceed max supply of Kasiar"
      );
      require(price * num <= msg.value, "Ether value sent is not correct");
        

      for (uint256 i; i < num; i++) {
        // We cannot just use balanceOf to create the new tokenId because tokens
        // can be burned (destroyed), so we need a separate counter.
        _mindRandom(to);
      }
    }

    function _mindRandom(address to) private {
        uint256  _r = _random();
        uint256  _mintId;
        if(0<=_r && _r<SSS && _tokenIdTrackerSSS<SSS){
            _mintId = _tokenIdTrackerSSS;
            _tokenIdTrackerSSS += _tokenIdTrackerSSS;
        } else if(0<=_r&& _r<SSS+SS && _tokenIdTrackerSS<SS){
            _mintId = _tokenIdTrackerSS;
            _tokenIdTrackerSS += 1;
        } else if(0<=_r && _r<SSS+SS+S && _tokenIdTrackerS<S){
            _mintId = _tokenIdTrackerS;
            _tokenIdTrackerS+=1;
        } else {
            if(_tokenIdTrackerA >= A){
                if(_tokenIdTrackerS>=S){
                    if(_tokenIdTrackerSS>=SS){
                        _mintId = _tokenIdTrackerSSS;
                        _tokenIdTrackerSSS+=1;
                    } else {
                        _mintId = _tokenIdTrackerSS;
                        _tokenIdTrackerSS+=1;
                    }
                } else {
                    _mintId = _tokenIdTrackerS;
                    _tokenIdTrackerS+=1;
                }
            }else {
                 _mintId = _tokenIdTrackerA;
                _tokenIdTrackerA+=1;
            }
            
        }
        _safeMint(to, _mintId);
    }
    function _random() private view returns (uint256) {
        return
            uint256(
                keccak256(
                    abi.encodePacked(
                        block.difficulty,
                        block.timestamp,
                       totalSupply()
                    )
                )
            ) % MAX_Kasiar;
    }
    function setSaleState(uint256 _saleState)   
        public
        virtual
        onlyOwner
    {
        saleState = _saleState;
    }
    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }
    function setBaseTokenURI(string memory baseTokenURI_)  
        public
        virtual
        onlyOwner 
    {
        _baseTokenURI = baseTokenURI_;
    }
    function setPrice(uint256 _price)   
        public
        virtual
        onlyOwner 
    {
        require(_price > 0, "Zero price");
        price = _price;
    }

    function setMaxPurchase(uint256 _value)   
        public
        virtual
        onlyOwner 
    {
        require(_value > 0, "Very low value");
        maxPurchase = _value;
    }

    function withdraw() public payable onlyOwner  {
        require(payable(msg.sender).send(address(this).balance));
    }
    function walletOfOwner(address _owner)
        public
        view
        returns (uint256[] memory)
    {
        uint256 tokenCount = balanceOf(_owner);

        uint256[] memory tokensId = new uint256[](tokenCount);
        for (uint256 i; i < tokenCount; i++) {
            tokensId[i] = tokenOfOwnerByIndex(_owner, i);
        }
        return tokensId;
    }

    function getMyAssets(address _owner, uint256 index)
        public
        view
        returns (uint256)
    {
        uint256 tokensId = tokenOfOwnerByIndex(_owner, index);
        return tokensId;
    }
}
