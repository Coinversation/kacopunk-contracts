// SPDX-License-Identifier: MIT
// Karsier
// KAS
// https://karsier.kaco.finance/karsier/
pragma solidity ^0.8.0;
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract Karsier is ERC721Enumerable, Ownable {
    using Strings for uint256;
    uint256 public price = 50000000000000000; // 0.05
    uint256 public constant maxPurchase = 10;
    uint256 public constant MAX_Karsier = 3000;
    string private _baseTokenURI;
    // 0 = paused, 1 = live
    uint256 public saleState = 0;
    mapping(address => uint256) public vipSaleReserved;

    // Rarity
    // 0 <= _tokenIdTrackerSSS < 2  2
    uint256 public constant SSS = 2;
    uint256 private _tokenIdTrackerSSS;
    // 2 <= _tokenIdTrackerSS < 18   16
    uint256 public constant SS = 16;
    uint256 private _tokenIdTrackerSS = 2;
    // 18 <= _tokenIdTrackerSS < 82  64
    uint256 public constant S = 64;
    uint256 private _tokenIdTrackerS = SSS + SS;
    // 82 <= _tokenIdTrackerSS < 3000  2918
    uint256 public constant A = 2918;
    uint256 private _tokenIdTrackerA = SSS + SS + S;

    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` and `ADMIN_ROLE` to the
     * account that deploys the contract.
     *
     * Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(
        string memory name,
        string memory symbol,
        string memory baseTokenURI
    ) ERC721(name, symbol) {
        _baseTokenURI = baseTokenURI;
        vipSaleReserved[msg.sender] = 1;
    }

    function setVipSaleWhitelist(address[] memory _a) public virtual onlyOwner {
        for (uint256 i; i < _a.length; i++) {
            vipSaleReserved[_a[i]] = 1;
        }
    }

    function mint(address to, uint256 num) public payable virtual {
        require(saleState > 0, "Sale not live");
        require(num > 0, "Cannot buy 0");
        require(to != address(0x0), "address err");
        require(
            num <= maxPurchase,
            "Exceeds max number of Karsier in one transaction"
        );
        uint256 reservedAmt = vipSaleReserved[to];
        uint256 _num = num - reservedAmt;
        uint256 _price = reservedAmt > 0
            ? _num > 0 ? (price * 1) / 2 + price * _num : (price * 1) / 2
            : price * _num;
        require(_price <= msg.value, "Ether value sent is not correct");

        uint256 supply = totalSupply();

        if (reservedAmt > 0) {
            require(
                supply + 1 <= MAX_Karsier,
                "Purchase would exceed max supply of Karsier"
            );
            _mindRandom(to);
            vipSaleReserved[to] = 0;
        }
        if (_num > 0) {
            require(
                supply + _num <= MAX_Karsier,
                "Purchase would exceed max supply of Karsier"
            );
            for (uint256 i; i < _num; i++) {
                _mindRandom(to);
            }
        }
    }

    function _mindRandom(address to) private {
        uint256 _r = _random();
        uint256 _mintId;

        uint256 _SSS = SSS;
        uint256 _SS = SS;
        uint256 _S = S;
        uint256 _A = A;

        if (0 <= _r && _r < _SSS && _tokenIdTrackerSSS < _SSS) {
            _mintId = _tokenIdTrackerSSS;
            _tokenIdTrackerSSS += 1;
        } else if (0 <= _r && _r < _SSS + _SS && _tokenIdTrackerSS < _SS) {
            _mintId = _tokenIdTrackerSS;
            _tokenIdTrackerSS += 1;
        } else if (0 <= _r && _r < _SSS + _SS + _S && _tokenIdTrackerS < _S) {
            _mintId = _tokenIdTrackerS;
            _tokenIdTrackerS += 1;
        } else {
            if (_tokenIdTrackerA >= _A) {
                if (_tokenIdTrackerS >= _S) {
                    if (_tokenIdTrackerSS >= _SS) {
                        _mintId = _tokenIdTrackerSSS;
                        _tokenIdTrackerSSS += 1;
                    } else {
                        _mintId = _tokenIdTrackerSS;
                        _tokenIdTrackerSS += 1;
                    }
                } else {
                    _mintId = _tokenIdTrackerS;
                    _tokenIdTrackerS += 1;
                }
            } else {
                _mintId = _tokenIdTrackerA;
                _tokenIdTrackerA += 1;
            }
        }
        _safeMint(to, _mintId);
    }

    function _random() private view returns (uint256) {
        return
            uint256(
                keccak256(
                    abi.encodePacked(
                        block.difficulty,
                        block.timestamp,
                        totalSupply()
                    )
                )
            ) % MAX_Karsier;
    }

    function setSaleState(uint256 _saleState) public virtual onlyOwner {
        require(saleState >= 0, "Sale state cannot < 0");
        require(saleState < 2, "Sale state cannot > 1");
        saleState = _saleState;
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    function setBaseTokenURI(string memory baseTokenURI_)
        public
        virtual
        onlyOwner
    {
        _baseTokenURI = baseTokenURI_;
    }

    function setPrice(uint256 _price) public virtual onlyOwner {
        require(_price > 0, "Zero price");
        price = _price;
    }

    function withdraw() public payable onlyOwner {
        require(payable(msg.sender).send(address(this).balance));
    }

    function walletOfOwner(address _owner)
        public
        view
        returns (uint256[] memory)
    {
        uint256 tokenCount = balanceOf(_owner);

        uint256[] memory tokensId = new uint256[](tokenCount);
        for (uint256 i; i < tokenCount; i++) {
            tokensId[i] = tokenOfOwnerByIndex(_owner, i);
        }
        return tokensId;
    }

    function getMyAssets(address _owner, uint256 index)
        public
        view
        returns (uint256)
    {
        uint256 tokensId = tokenOfOwnerByIndex(_owner, index);
        return tokensId;
    }

    function tokenURI(uint256 _tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(
            _exists(_tokenId),
            "ERC721Metadata: URI query for nonexistent token"
        );

        return
            bytes(_baseTokenURI).length > 0
                ? string(
                    abi.encodePacked(
                        _baseTokenURI,
                        _tokenId.toString(),
                        ".json"
                    )
                )
                : "";
    }
}
